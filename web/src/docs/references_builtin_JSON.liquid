---
layout: default.liquid
title: JSON
---

<h1>JSON</h1>
<h2>Classes</h2>
<h3>Json_Array</h3>
<h4>Methods</h4>
<h5>add</h5>
<p>Add a value to the end of a JSON array.</p>
<p>void json_array::add(var@ value);</p>
<h6>Arguments:</h6>
<ul>
<li>var@ value: a handle to the value to be set.</li>
</ul>
<h6>Example:</h6>
<pre><code>void main() {
	json_array@ arr = parse_json(&quot;[]&quot;);
	for (uint i = 0; i &lt; 5; i++)
		arr.add(random(1, 100));
	alert(&quot;Filled array&quot;, arr.stringify());
}
</code></pre>
<h5>clear</h5>
<p>Clears the JSON array completely.</p>
<p>void json_array::clear();</p>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;[1, 2, 3, 4, 5]&quot;;
	json_array@ arr = parse_json(data);
	alert(&quot;Before being cleared&quot;, arr.stringify());
	arr.clear();
	alert(&quot;After being cleared&quot;, arr.stringify());
}
</code></pre>
<h5>is_array</h5>
<p>Determine if the value at the given index is a JSON array or not.</p>
<p>bool json_array::is_array(uint index);</p>
<h6>Arguments:</h6>
<ul>
<li>uint index: the position of the item.</li>
</ul>
<h6>Returns:</h6>
<p>bool: true if the value at the specified index is a JSON array, false otherwise.</p>
<h6>Example:</h6>
<pre><code>void main() {
	json_array@ arr = parse_json(&quot;[[1, 2], [3, 4]]&quot;);
	alert(&quot;Info&quot;, arr.is_array(1) ? &quot;It is an array&quot;: &quot;It is not an array&quot;);
}
</code></pre>
<h5>is_null</h5>
<p>Determine if the value at the given index is null.</p>
<p>bool json_array::is_null(uint index);</p>
<h6>Arguments:</h6>
<ul>
<li>uint index: the position of the item.</li>
</ul>
<h6>Returns:</h6>
<p>bool: true if the value at the specified index is null, false otherwise.</p>
<h6>Example:</h6>
<pre><code>void main() {
	json_array@ arr = parse_json(&quot;[1, 2, null, 4]&quot;);
	alert(&quot;Info&quot;, &quot;Index 1 &quot; + (arr.is_null(1) ? &quot; is null&quot;: &quot; is not null&quot;));
	alert(&quot;Info&quot;, &quot;Index 2 &quot; + (arr.is_null(2) ? &quot; is null&quot;: &quot; is not null&quot;));
}
</code></pre>
<h5>is_object</h5>
<p>Determine if the value at the given index is a JSON object.</p>
<p>bool json_array::is_object(uint index);</p>
<h6>Arguments:</h6>
<ul>
<li>uint index: the position of the item.</li>
</ul>
<h6>Returns:</h6>
<p>bool: true if the value at the specified index is a JSON object, false otherwise.</p>
<h6>Example:</h6>
<pre><code>void main() {
	json_array@ arr = parse_json(&quot;&quot;&quot;[{}, {}, &quot;test&quot;, {}]&quot;&quot;&quot;);
	alert(&quot;Info&quot;, &quot;Position 0 &quot; + (arr.is_object(0) ? &quot;is an object&quot; : &quot;is not an object&quot;));
	alert(&quot;Info&quot;, &quot;Position 2 &quot; + (arr.is_object(2) ? &quot;is an object&quot;: &quot;is not an object&quot;));
}
</code></pre>
<h5>remove</h5>
<p>Remove a value from the JSON array given an index.</p>
<p>void json_array::remove(uint index);</p>
<h6>Arguments:</h6>
<ul>
<li>uint index: the index of the value to remove.</li>
</ul>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;[47, 4, 584, 43, 8483]&quot;&quot;&quot;;
	json_array@ arr = parse_json(data);
	alert(&quot;Initial&quot;, arr.stringify());
	arr.remove(2);
	alert(&quot;After removal&quot;, arr.stringify());
}
</code></pre>
<h5>size</h5>
<p>Return the size of the JSON array.</p>
<p>uint json_array::size();</p>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;[&quot;;
	for (int i = 0; i &lt; random(10, 20); i++)
		data += i + &quot;, &quot;;
	// Strip off the trailing comma and space character, as they'll make the JSON throw a syntax error.
	data.erase(data.length() - 1);
	data.erase(data.length() - 1);
	data += &quot;]&quot;;
	clipboard_set_text(data);
	json_array@ arr = parse_json(data);
	alert(&quot;Info&quot;, &quot;The JSON array contains &quot; + arr.size() + &quot; items&quot;);
}
</code></pre>
<h5>stringify</h5>
<p>Return the JSON array as a string.</p>
<p>string json_array::stringify(int indent = 0, int step = -1);</p>
<h6>Arguments:</h6>
<ul>
<li><p>int indent = 0: specifies how many spaces to use to indent the JSON. If 0, no indentation or formatting is performed.</p>
</li>
<li><p>int step = -1: the outwards indentation step, for example setting it to two would cause your outdents to only be two spaces. -1 (the default) keeps it how it is, normally you don't need to use this parameter.</p>
</li>
</ul>
<h6>Returns:</h6>
<p>string: the JSON array as a string.</p>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;[&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;]&quot;&quot;&quot;;
	json_array@ arr = parse_json(data);
	alert(&quot;JSON array&quot;, arr.stringify(4));
}
</code></pre>
<h4>Operators</h4>
<h5>get_opIndex</h5>
<p>Get a value out of the JSON arraywith literal syntax, for example <code>arr[2]</code>.</p>
<p>var@ json_array::get_opIndex(uint index) property;</p>
<h6>Arguments:</h6>
<ul>
<li>uint index: the index of the value to get.</li>
</ul>
<h6>Returns:</h6>
<p>var@: a handle to the object, or null if not found.</p>
<h6>Example:</h6>
<pre><code>void main() {
	json_array@ cats = parse_json(&quot;&quot;&quot;[&quot;Athena&quot;, &quot;Willow&quot;, &quot;Punk&quot;, &quot;Franky&quot;, &quot;Yoda&quot;, &quot;Waffles&quot;]&quot;&quot;&quot;);
	alert(&quot;The third cat is&quot;, cats[2]);
	for (uint i = 0; i &lt; cats.size(); i++)
		alert(&quot;Awww&quot;, &quot;Hi &quot; + cats[i]);
}
</code></pre>
<h5>opCall</h5>
<p>Get a value out of a JSON array using a query.</p>
<p>var@ json_array::opCall(string query);</p>
<h6>Arguments:</h6>
<ul>
<li>string query: the JSON query (see the remarks section for details).</li>
</ul>
<h6>Returns:</h6>
<p>var@: a handle to the object, or null if it couldn't be found.</p>
<h6>Remarks:</h6>
<p>Queries are formatted like so, using key names and indexes seperated with &quot;.&quot;:</p>
<blockquote>
<p>world.player.0</p>
</blockquote>
<p>It can be as nested as you like.</p>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;[[[&quot;Colorado&quot;, &quot;Kansas&quot;, &quot;Minnesota&quot;]]]&quot;&quot;&quot;;
	json_array@ arr = parse_json(data);
	string location = arr(&quot;0.0.0&quot;);
	alert(&quot;My favorite state is&quot;, location);
}
</code></pre>
<h5>set_opIndex</h5>
<p>Set a value in the JSON array at a particular position.</p>
<p>void json_array::set_opIndex(uint index, var@ value) property;</p>
<h6>Arguments:</h6>
<ul>
<li><p>uint index: the index to insert the item at.</p>
</li>
<li><p>var@ value: the value to set.</p>
</li>
</ul>
<h6>Example:</h6>
<pre><code>void main() {
	json_array@ arr = parse_json(&quot;[]&quot;);
	arr[0] = &quot;meow&quot;;
	alert(&quot;Info&quot;, &quot;Cats say &quot; + arr[0]);
}
</code></pre>
<h4>Properties</h4>
<h5>empty</h5>
<p>Determine if the JSON array is empty.</p>
<p>const bool json_array::empty;</p>
<h6>Example:</h6>
<pre><code>void main() {
	json_array@ arr = parse_json(&quot;[]&quot;);
	json_array@ arr2 = parse_json(&quot;[1, 2, 3]&quot;);
	alert(&quot;First is empty&quot;, arr.empty ? &quot;true&quot; : &quot;false&quot;);
	alert(&quot;Second is empty&quot;, arr2.empty ? &quot;true&quot; : &quot;false&quot;);
}
</code></pre>
<h5>escape_unicode</h5>
<p>Determines the amount of escaping that occurs in JSON parsing.</p>
<p><code>bool json_array::escape_unicode;</code></p>
<h6>Remarks:</h6>
<p>If this property is true, escaping will behave like normal. If it's false, only the characters absolutely vital to JSON parsing are escaped.</p>
<h3>Json_Object</h3>
<h4>Methods</h4>
<h5>clear</h5>
<p>Clears the JSON object completely.</p>
<p>void json_object::clear();</p>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;{&quot;numbers&quot;: [1, 2, 3, 4, 5]}&quot;&quot;&quot;;
	json_object@ o = parse_json(data);
	alert(&quot;Before being cleared&quot;, o.stringify());
	o.clear();
	alert(&quot;After being cleared&quot;, o.stringify());
}
</code></pre>
<h5>exists</h5>
<p>Determine if a key exists in the JSON object.</p>
<p>bool json_object::exists(string key);</p>
<h6>Arguments:</h6>
<ul>
<li>string: the key to search for.</li>
</ul>
<h6>Returns:</h6>
<p>bool: true if the key exists, false if not.</p>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;{&quot;engine&quot;: &quot;NVGT&quot;}&quot;&quot;&quot;;
	json_object@ o = parse_json(data);
	alert(&quot;Info&quot;, (o.exists(&quot;engine&quot;) ? &quot;The key exists&quot; : &quot;The key does not exist&quot;));
}
</code></pre>
<h5>get_keys</h5>
<p>Get a list of all the keys in the JSON object.</p>
<p>string[]@ json_object::get_keys();</p>
<h6>Returns:</h6>
<p>string[]@: a handle to an array of strings containing all the keys of the JSON object.</p>
<h6>Remarks:</h6>
<p>Note that this function isn't recursive, you only get the keys for the object you're running this function on, not any child objects.</p>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;{&quot;thing&quot;: 1, &quot;other_thing&quot;: &quot;test&quot;, &quot;another&quot;: true}&quot;&quot;&quot;;
	json_object@ o = parse_json(data);
	string[]@ keys = o.get_keys();
	alert(&quot;The keys are&quot;, join(keys, &quot;, &quot;));
}
</code></pre>
<h5>is_array</h5>
<p>Determine if the value with the given key is a JSON array or not.</p>
<p>bool json_object::is_array(string key);</p>
<h6>Arguments:</h6>
<ul>
<li>string key: the key to query.</li>
</ul>
<h6>Returns:</h6>
<p>bool: true if the value with the specified key is a JSON array, false otherwise.</p>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;{&quot;classes&quot;: [&quot;json_object&quot;, &quot;json_array&quot;]}&quot;&quot;&quot;;
	json_object@ o = parse_json(data);
	alert(&quot;Info&quot;, o.is_array(&quot;classes&quot;) ? &quot;array&quot;: &quot;nonarray&quot;);
}
</code></pre>
<h5>is_null</h5>
<p>Determine if the value with the given key is null.</p>
<p>bool json_object::is_null(string key);</p>
<h6>Arguments:</h6>
<ul>
<li>string key: the key to query.</li>
</ul>
<h6>Returns:</h6>
<p>bool: true if the value with the specified key is null.</p>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;{&quot;brain&quot;: null}&quot;&quot;&quot;;
	json_object@ o = parse_json(data);
	alert(&quot;Info&quot;, o.is_null(&quot;brain&quot;) ? &quot;null&quot; : &quot;nonull&quot;);
}
</code></pre>
<h5>is_object</h5>
<p>Determine if the value with the given key is a JSON object or not.</p>
<p>bool json_object::is_object(string key);</p>
<h6>Arguments:</h6>
<ul>
<li>string key: the key to query.</li>
</ul>
<h6>Returns:</h6>
<p>bool: true if the value with the specified key is a JSON object, false otherwise.</p>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;{&quot;json_object&quot;: {}}&quot;&quot;&quot;;
	json_object@ o = parse_json(data);
	alert(&quot;Info&quot;, o.is_object(&quot;json_object&quot;) ? &quot;Object&quot; : &quot;Non-object&quot;);
}
</code></pre>
<h5>remove</h5>
<p>Remove a value from the JSON object given a key.</p>
<p>void json_object::remove(string key);</p>
<h6>Arguments:</h6>
<ul>
<li>string key: the key of the value to remove.</li>
</ul>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;{&quot;name&quot;: &quot;Quin&quot;}&quot;&quot;&quot;;
	json_object@ o = parse_json(data);
	alert(&quot;Initial&quot;, o.stringify());
	o.remove(&quot;name&quot;);
	alert(&quot;After removal&quot;, o.stringify());
}
</code></pre>
<h5>set</h5>
<p>Set a value in a JSON object.</p>
<p>void json_object::set(string key, var@ value);</p>
<h6>Arguments:</h6>
<ul>
<li><p>string key: the key to give the value.</p>
</li>
<li><p>var@ value: a handle to the value to be set.</p>
</li>
</ul>
<h6>Example:</h6>
<pre><code>void main() {
	json_object@ o = parse_json(&quot;{}&quot;);;
	o.set(&quot;nvgt_user&quot;, true);
	alert(&quot;Info&quot;, (bool(o[&quot;nvgt_user&quot;]) ? &quot;You are an NVGT user&quot; : &quot;You are not a regular NVGT user&quot;));
}
</code></pre>
<h5>size</h5>
<p>Return the size of the JSON object.</p>
<p>uint json_object::size();</p>
<h6>Remarks:</h6>
<p>Note that this function returns the number of top-level keys; it's not recursive.</p>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;{&quot;numbers&quot;: [1, 2, 3, 4, 5]}&quot;&quot;&quot;;
	json_object@ o = parse_json(data);
	alert(&quot;Info&quot;, &quot;The json object's size is &quot; + o.size());
}
</code></pre>
<h5>stringify</h5>
<p>Return the JSON object as a string.</p>
<p>string json_object::stringify(int indent = 0, int step = -1);</p>
<h6>Arguments:</h6>
<ul>
<li><p>int indent = 0: specifies how many spaces to use to indent the JSON. If 0, no indentation or formatting is performed.</p>
</li>
<li><p>int step = -1: the outwards indentation step, for example setting it to two would cause your outdents to only be two spaces. -1 (the default) keeps it how it is, normally you don't need to use this parameter.</p>
</li>
</ul>
<h6>Returns:</h6>
<p>string: the JSON object as a string.</p>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;{&quot;name&quot;: &quot;Quin&quot;, &quot;age&quot;: 18}&quot;&quot;&quot;;
	json_object@ o = parse_json(data);
	alert(&quot;JSON object&quot;, o.stringify(4));
}
</code></pre>
<h4>Operators</h4>
<h5>get_opIndex</h5>
<p>Get a value out of the JSON object with literal syntax, for example <code>json[&quot;key&quot;]</code>.</p>
<p>var@ json_object::get_opIndex(string key) property;</p>
<h6>Arguments:</h6>
<ul>
<li>string key: the key of the object to get.</li>
</ul>
<h6>Returns:</h6>
<p>var@: a handle to the object, or null if not found.</p>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;{&quot;name&quot;: &quot;Quin&quot;, &quot;age&quot;: 18}&quot;&quot;&quot;;
	json_object@ o = parse_json(data);
	alert(&quot;Info&quot;, o[&quot;name&quot;] + &quot; is &quot; + o[&quot;age&quot;]);
}
</code></pre>
<h5>opCall</h5>
<p>Get a value out of a JSON object using a query.</p>
<p>var@ json_object::opCall(string query);</p>
<h6>Arguments:</h6>
<ul>
<li>string query: the JSON query (see the remarks section for details).</li>
</ul>
<h6>Returns:</h6>
<p>var@: a handle to the object, null if not found.</p>
<h6>Remarks:</h6>
<p>Queries are formatted like so:</p>
<blockquote>
<p>first_field.subfield.subfield</p>
</blockquote>
<p>It can be as nested as you like.</p>
<p>This method also works on json_array's, and you access array indexes just with their raw numbers, like so:</p>
<blockquote>
<p>world.players.0</p>
</blockquote>
<h6>Example:</h6>
<pre><code>void main() {
	string data = &quot;&quot;&quot;{&quot;countries&quot;:{&quot;us&quot;:[&quot;Colorado&quot;, &quot;Kansas&quot;, &quot;Minnesota&quot;]}}&quot;&quot;&quot;;
	json_object@ o = parse_json(data);
	string locations = o(&quot;countries.us&quot;);
	alert(&quot;My favorite states are&quot;, locations);
}
</code></pre>
<h5>set_opIndex</h5>
<p>Set a value in the JSON object with a particular key.</p>
<p>void json_object::set_opIndex(string key, var@ value) property;</p>
<h6>Arguments:</h6>
<ul>
<li><p>string key: the key of the object.</p>
</li>
<li><p>var@ value: the value to set.</p>
</li>
</ul>
<h6>Example:</h6>
<pre><code>void main() {
	json_object@ o = parse_json(&quot;{}&quot;);
	o[&quot;name&quot;] = &quot;Quin&quot;;
	alert(&quot;Hi&quot;, &quot;I am &quot; + o[&quot;name&quot;]);
}
</code></pre>
<h4>Properties</h4>
<h5>escape_unicode</h5>
<p>Determines the amount of escaping that occurs in JSON parsing.</p>
<p><code>bool json_object::escape_unicode;</code></p>
<h6>Remarks:</h6>
<p>If this property is true, escaping will behave like normal. If it's false, only the characters absolutely vital to JSON parsing are escaped.</p>
