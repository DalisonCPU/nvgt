/* tests.nvgt - main test runner application
 * In our case, it's actually better to write our tests directly in Angelscript, as any specific parts of the c++ code will be tested by loading and executing this Angelscript code which can test engine features in the same way as end-users will be employing them.
 *
 * NVGT - NonVisual Gaming Toolkit
 * Copyright (c) 2022-2024 Sam Tupy
 * https://nvgt.gg
 * This software is provided "as-is", without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
 * 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
*/

#pragma console
#include "case/*.nvgt"

dictionary disabled_tests;
bool verbose = false;
script_module@ nvgt_game = script_get_module("nvgt_game");

void help() {
	println("NVGT tests program available options:");
	println("-v (verbose), print status information.");
	println("-d (disable), do not run a given test (-dbase64).");
	println("-h (help), This message.");
	exit();
}
void main() {
	// Very oversimplified command line parsing.
	for (uint i = 1; i < ARGS.length(); i++) {
		if (ARGS[i] == "-h") help();
		else if(ARGS[i] == "-v") verbose = true;
		else if(ARGS[i].starts_with("-d")) disabled_tests.set(ARGS[i].substr(2), true);
		else {
			println("unknown command line option " + ARGS[i]);
			exit(64);
		}
	}
	// These tests are either intended to run from source or along side the source.
	string[]@ files = find_files("case/*.nvgt");
	for (uint i = 0; i < files.length(); i++) {
		test(spec::path(files[i]).basename);
	}
	println("All tests have passed successfully!");
}
void test(const string&in testcase) {
	if (disabled_tests.exists(testcase)) {
		if (verbose) println("Skipping " + testcase + " (commandline)");
		return;
	}
	// It is possible to skip a test by creating a global variable in the test case called bool test_<case>_skip = true;
	any@ v_skip = nvgt_game.get_global(nvgt_game.get_global_index_by_decl("bool test_" + testcase + "_skip"));
	bool b_skip = false;
	if (@v_skip != null and v_skip.retrieve(b_skip) and b_skip) {
		if (verbose) println("Skipping " + testcase + " (script)");
		return;
	}
	script_function@ func = nvgt_game.get_function_by_name(testcase);
	if (@func == null) {
		println("Error, test case " + testcase + " is badly formatted, can't find void " + testcase + "()");
		exit(64);
	}
	string[] errors;
	if (verbose) print("Testing " + testcase + "... ");
	func({}, errors);
	if (errors.length() < 1) {
		if (verbose) println("OK");
		return;
	}
	if (verbose) println("FAILED!");
	else println("TEST " + testcase + " FAILED!");
	for (uint i = 1; i < errors.length(); i++) println(errors[i]);
	println(errors[0]); // Move the exception itself to the bottom of the output to avoid waiding through the call stack when unwanted.
	exit(1);
}
